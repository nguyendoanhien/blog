<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>C# &#8211; 9x Developers&#039;s Blog</title>
	<atom:link href="https://blog.9xdevelopers.com/tag/c/feed/" rel="self" type="application/rss+xml" />
	<link>https://blog.9xdevelopers.com/</link>
	<description>Learning and sharing developer&#039;s experiences</description>
	<lastBuildDate>Thu, 03 Sep 2020 07:01:14 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.5.1</generator>

<image>
	<url>https://blog.9xdevelopers.com/wp-content/uploads/2020/08/cropped-9x-logo-3-32x32.png</url>
	<title>C# &#8211; 9x Developers&#039;s Blog</title>
	<link>https://blog.9xdevelopers.com/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>C# Coding Standards and Naming Conventions</title>
		<link>https://blog.9xdevelopers.com/csharp-coding-standards-and-naming-conventions/?utm_source=rss&#038;utm_medium=rss&#038;utm_campaign=csharp-coding-standards-and-naming-conventions</link>
		
		<dc:creator><![CDATA[Hien Nguyen]]></dc:creator>
		<pubDate>Mon, 06 Apr 2020 05:49:17 +0000</pubDate>
				<category><![CDATA[C#]]></category>
		<guid isPermaLink="false">https://blog.9xdevelopers.com/?p=62</guid>

					<description><![CDATA[<p>Here are some coding conventions that every C# developer should know</p>
<p>The post <a rel="nofollow" href="https://blog.9xdevelopers.com/csharp-coding-standards-and-naming-conventions/">C# Coding Standards and Naming Conventions</a> appeared first on <a rel="nofollow" href="https://blog.9xdevelopers.com/">9x Developers&#039;s Blog</a>.</p>
]]></description>
										<content:encoded><![CDATA[<span class="rt-reading-time" style="display: block;"><span class="rt-label rt-prefix">Thời gian đọc:</span> <span class="rt-time">5</span> <span class="rt-label rt-postfix">phút.</span></span><p>s# C# Coding Standards and Naming Conventions</p>
<table>
<thead>
<tr>
<th align="left">Object Name</th>
<th align="left">Notation</th>
<th align="right">Length</th>
<th align="left">Plural</th>
<th align="left">Prefix</th>
<th align="left">Suffix</th>
<th align="left">Abbreviation</th>
<th align="left">Char Mask</th>
<th align="left">Underscores</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">Class name</td>
<td align="left">PascalCase</td>
<td align="right">128</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">Yes</td>
<td align="left">No</td>
<td align="left">[A-z][0-9]</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">Constructor name</td>
<td align="left">PascalCase</td>
<td align="right">128</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">Yes</td>
<td align="left">No</td>
<td align="left">[A-z][0-9]</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">Method name</td>
<td align="left">PascalCase</td>
<td align="right">128</td>
<td align="left">Yes</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">[A-z][0-9]</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">Method arguments</td>
<td align="left">camelCase</td>
<td align="right">128</td>
<td align="left">Yes</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">Yes</td>
<td align="left">[A-z][0-9]</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">Local variables</td>
<td align="left">camelCase</td>
<td align="right">50</td>
<td align="left">Yes</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">Yes</td>
<td align="left">[A-z][0-9]</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">Constants name</td>
<td align="left">PascalCase</td>
<td align="right">50</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">[A-z][0-9]</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">Field name</td>
<td align="left">camelCase</td>
<td align="right">50</td>
<td align="left">Yes</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">Yes</td>
<td align="left">[A-z][0-9]</td>
<td align="left">Yes</td>
</tr>
<tr>
<td align="left">Properties name</td>
<td align="left">PascalCase</td>
<td align="right">50</td>
<td align="left">Yes</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">Yes</td>
<td align="left">[A-z][0-9]</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">Delegate name</td>
<td align="left">PascalCase</td>
<td align="right">128</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">[A-z]</td>
<td align="left">No</td>
</tr>
<tr>
<td align="left">Enum type name</td>
<td align="left">PascalCase</td>
<td align="right">128</td>
<td align="left">Yes</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">No</td>
<td align="left">[A-z]</td>
<td align="left">No</td>
</tr>
</tbody>
</table>
<h4>1. Do use PascalCasing for class names and method names:</h4>
<pre><code class="language-csharp ">public class ClientActivity
{
  public void ClearStatistics()
  {
    //...
  }
  public void CalculateStatistics()
  {
    //...
  }
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and easy to read.</em></strong></p>
<h4>2. Do use camelCasing for method arguments and local variables:</h4>
<pre><code class="language-csharp ">public class UserLog
{
  public void Add(LogEvent logEvent)
  {
    int itemCount = logEvent.Items.Count;
    // ...
  }
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and easy to read.</em></strong></p>
<h4>3. Do not use Hungarian notation or any other type identification in identifiers</h4>
<pre><code class="language-csharp ">// Correct
int counter;
string name;    
// Avoid
int iCounter;
string strName;
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and Visual Studio IDE makes determining types very easy (via tooltips). In general you want to avoid type indicators in any identifier.</em></strong></p>
<h4>4. Do not use Screaming Caps for constants or readonly variables:</h4>
<pre><code class="language-csharp ">// Correct
public const string ShippingType = "DropShip";
// Avoid
public const string SHIPPINGTYPE = "DropShip";
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework. Caps grab too much attention.</em></strong></p>
<h4>5. Use meaningful names for variables. The following example uses seattleCustomers for customers who are located in Seattle:</h4>
<pre><code class="language-csharp ">var seattleCustomers = from customer in customers
  where customer.City == "Seattle" 
  select customer.Name;
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and easy to read.</em></strong></p>
<h4>6. Avoid using Abbreviations. Exceptions: abbreviations commonly used as names, such as Id, Xml, Ftp, Uri.</h4>
<pre><code class="language-csharp ">// Correct
UserGroup userGroup;
Assignment employeeAssignment;     
// Avoid
UserGroup usrGrp;
Assignment empAssignment; 
// Exceptions
CustomerId customerId;
XmlDocument xmlDocument;
FtpHelper ftpHelper;
UriPart uriPart;
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and prevents inconsistent abbreviations.</em></strong></p>
<h4>7. Do use PascalCasing for abbreviations 3 characters or more (2 chars are both uppercase):</h4>
<pre><code class="language-csharp ">HtmlHelper htmlHelper;
FtpTransfer ftpTransfer;
UIControl uiControl;
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework. Caps would grab visually too much attention.</em></strong></p>
<h4>8. Do not use Underscores in identifiers. Exception: you can prefix private fields with an underscore:</h4>
<pre><code class="language-csharp ">// Correct
public DateTime clientAppointment;
public TimeSpan timeLeft;    
// Avoid
public DateTime client_Appointment;
public TimeSpan time_Left; 
// Exception (Class field)
private DateTime _registrationDate;
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and makes code more natural to read (without &#8216;slur&#8217;). Also avoids underline stress (inability to see underline).</em></strong></p>
<h4>9. Do use predefined type names (C# aliases) like <code>int</code>, <code>float</code>, <code>string</code> for local, parameter and member declarations. Do use .NET Framework names like <code>Int32</code>, <code>Single</code>, <code>String</code> when accessing the type&#8217;s static members like <code>Int32.TryParse</code> or <code>String.Join</code>.</h4>
<pre><code class="language-csharp ">// Correct
string firstName;
int lastIndex;
bool isSaved;
string commaSeparatedNames = String.Join(", ", names);
int index = Int32.Parse(input);
// Avoid
String firstName;
Int32 lastIndex;
Boolean isSaved;
string commaSeparatedNames = string.Join(", ", names);
int index = int.Parse(input);
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and makes code more natural to read.</em></strong></p>
<h4>10. Do use implicit type var for local variable declarations. Exception: primitive types (int, string, double, etc) use predefined names.</h4>
<pre><code class="language-csharp ">var stream = File.Create(path);
var customers = new Dictionary();
// Exceptions
int index = 100;
string timeSheet;
bool isCompleted;
</code></pre>
<p><strong><em>Why: removes clutter, particularly with complex generic types. Type is easily detected with Visual Studio tooltips.</em></strong></p>
<h4>11. Do use noun or noun phrases to name a class.</h4>
<pre><code class="language-csharp ">public class Employee
{
}
public class BusinessLocation
{
}
public class DocumentCollection
{
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and easy to remember.</em></strong></p>
<h4>12. Do prefix interfaces with the letter I. Interface names are noun (phrases) or adjectives.</h4>
<pre><code class="language-csharp ">public interface IShape
{
}
public interface IShapeCollection
{
}
public interface IGroupable
{
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework.</em></strong></p>
<h4>13. Do name source files according to their main classes. Exception: file names with partial classes reflect their source or purpose, e.g. designer, generated, etc.</h4>
<pre><code class="language-csharp ">// Located in Task.cs
public partial class Task
{
}
// Located in Task.generated.cs
public partial class Task
{
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft practices. Files are alphabetically sorted and partial classes remain adjacent.</em></strong></p>
<h4>14. Do organize namespaces with a clearly defined structure:</h4>
<pre><code class="language-csharp ">// Examples
namespace Company.Product.Module.SubModule
{
}
namespace Product.Module.Component
{
}
namespace Product.Layer.Module.Group
{
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework. Maintains good organization of your code base.</em></strong></p>
<h4>15. Do vertically align curly brackets:</h4>
<pre><code class="language-csharp ">// Correct
class Program
{
  static void Main(string[] args)
  {
    //...
  }
}
</code></pre>
<p><strong><em>Why: Microsoft has a different standard, but developers have overwhelmingly preferred vertically aligned brackets.</em></strong></p>
<h4>16. Do declare all member variables at the top of a class, with static variables at the very top.</h4>
<pre><code class="language-csharp ">// Correct
public class Account
{
  public static string BankName;
  public static decimal Reserves;      
  public string Number { get; set; }
  public DateTime DateOpened { get; set; }
  public DateTime DateClosed { get; set; }
  public decimal Balance { get; set; }     
  // Constructor
  public Account()
  {
    // ...
  }
}
</code></pre>
<p><strong><em>Why: generally accepted practice that prevents the need to hunt for variable declarations.</em></strong></p>
<h4>17. Do use singular names for enums. Exception: bit field enums.</h4>
<pre><code class="language-csharp ">// Correct
public enum Color
{
  Red,
  Green,
  Blue,
  Yellow,
  Magenta,
  Cyan
} 
// Exception
[Flags]
public enum Dockings
{
  None = 0,
  Top = 1,
  Right = 2, 
  Bottom = 4,
  Left = 8
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and makes the code more natural to read. Plural flags because enum can hold multiple values (using bitwise &#8216;OR&#8217;).</em></strong></p>
<h4>18. Do not explicitly specify a type of an enum or values of enums (except bit fields):</h4>
<pre><code class="language-csharp ">// Don't
public enum Direction : long
{
  North = 1,
  East = 2,
  South = 3,
  West = 4
} 
// Correct
public enum Direction
{
  North,
  East,
  South,
  West
}
</code></pre>
<p><strong><em>Why: can create confusion when relying on actual types and values.</em></strong></p>
<h4>19. Do not use an &#8220;Enum&#8221; suffix in enum type names:</h4>
<pre><code class="language-csharp ">// Don't
public enum CoinEnum
{
  Penny,
  Nickel,
  Dime,
  Quarter,
  Dollar
} 
// Correct
public enum Coin
{
  Penny,
  Nickel,
  Dime,
  Quarter,
  Dollar
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and consistent with prior rule of no type indicators in identifiers.</em></strong></p>
<h4>20. Do not use &#8220;Flag&#8221; or &#8220;Flags&#8221; suffixes in enum type names:</h4>
<pre><code class="language-csharp ">// Don't
[Flags]
public enum DockingsFlags
{
  None = 0,
  Top = 1,
  Right = 2, 
  Bottom = 4,
  Left = 8
}
// Correct
[Flags]
public enum Dockings
{
  None = 0,
  Top = 1,
  Right = 2, 
  Bottom = 4,
  Left = 8
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and consistent with prior rule of no type indicators in identifiers.</em></strong></p>
<h4>21. Do use suffix EventArgs at creation of the new classes comprising the information on event:</h4>
<pre><code class="language-csharp ">// Correct
public class BarcodeReadEventArgs : System.EventArgs
{
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and easy to read.</em></strong></p>
<h4>22. Do name event handlers (delegates used as types of events) with the &#8220;EventHandler&#8221; suffix, as shown in the following example:</h4>
<pre><code class="language-csharp ">public delegate void ReadBarcodeEventHandler(object sender, ReadBarcodeEventArgs e);
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and easy to read.</em></strong></p>
<h4>23. Do not create names of parameters in methods (or constructors) which differ only by the register:</h4>
<pre><code class="language-csharp ">// Avoid
private void MyFunction(string name, string Name)
{
  //...
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and easy to read, and also excludes possibility of occurrence of conflict situations.</em></strong></p>
<h4>24. DO use two parameters named sender and e in event handlers. The sender parameter represents the object that raised the event. The sender parameter is typically of type object, even if it is possible to employ a more specific type.</h4>
<pre><code class="language-csharp ">public void ReadBarcodeEventHandler(object sender, ReadBarcodeEventArgs e)
{
  //...
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework</em></strong></p>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and consistent with prior rule of no type indicators in identifiers.</em></strong></p>
<h4>25. Do use suffix Exception at creation of the new classes comprising the information on exception:</h4>
<pre><code class="language-csharp ">// Correct
public class BarcodeReadException : System.Exception
{
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and easy to read.</em></strong></p>
<h4>26. Do use prefix Any, Is, Have or similar keywords for boolean identifier :</h4>
<pre><code class="language-csharp ">// Correct
public static bool IsNullOrEmpty(string value) {
    return (value == null || value.Length == 0);
}
</code></pre>
<p><strong><em>Why: consistent with the Microsoft&#8217;s .NET Framework and easy to read.</em></strong></p>
<h2>Offical Reference</h2>
<ol>
<li><a class="wp-editor-md-post-content-link" href="http://msdn.microsoft.com/en-us/library/ms229045(v=vs.110).aspx">MSDN General Naming Conventions</a></li>
<li><a class="wp-editor-md-post-content-link" href="http://www.dofactory.com/reference/csharp-coding-standards">DoFactory C# Coding Standards and Naming Conventions</a></li>
<li><a class="wp-editor-md-post-content-link" href="http://msdn.microsoft.com/en-us/library/xzf533w0%28v=vs.71%29.aspx">MSDN Naming Guidelines</a></li>
<li><a class="wp-editor-md-post-content-link" href="http://msdn.microsoft.com/en-us/library/ms229042.aspx">MSDN Framework Design Guidelines</a></li>
</ol>
<p>The post <a rel="nofollow" href="https://blog.9xdevelopers.com/csharp-coding-standards-and-naming-conventions/">C# Coding Standards and Naming Conventions</a> appeared first on <a rel="nofollow" href="https://blog.9xdevelopers.com/">9x Developers&#039;s Blog</a>.</p>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
